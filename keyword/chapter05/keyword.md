## - 키워드 정리

#### - Domain

- 소프트웨어로 해결하고자 하는 문제 영역

- 사용자가 이용하는 앱 기능, 회사의 비즈니스 로직을 정의하는 영역

- ex) 온라인서점 사이트를 개발한다면, 온라인 서점은 도메인이 될 수 있다. 온라인 서점 도메인은 다시 주문, 결제, 배송같은 하위 도메인으로도 나뉠 수 있다.

- **Domain vs Entity**

    - Domain은 서비스를 대표하는 개념이고, Entity는 Domain 내에 식별 가능한 객체

    - 도메인 객체가 다시 Entity와 Value Object(VO)로 나뉜다.

    - Entity

        - 식별자를 갖는 객체

    - Value Object

        - 식별자를 가지지 않는 값 그 자체.

#### - 양방향 매핑

- 두 엔티티가 서로를 참조하는 관계

- 데이터베이스 테이블은 외래 키 하나로 양방향을 조회할 수 있지만, **JPA에서는 단방향 연관관계 2개를 묶어 양방향 연관관계를 구현한다*.*

- 따라서 JPA에서는 **두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야 하고,** 이를 **연관관계의 주인**이라고 한다.

- **연관관계의 주인**

    - **테이블에 외래 키가 있는 곳**으로 정해야 하며, **1:N 관계에서 N 쪽이 연관관계의 주인으로 하는 것이 좋다.**

    - @ManyToOne이 기본

    - 주인이 아님을 표시하는 속성에는 mappedBy 속성을 넣는다.

- **양방향 연관관계 주의점**

    - Member와 Team이 N:1 관계로 있다고 할 때, Member에도 Team을 주입해주고(member.setTeam(team)), Team에도 member를 주입해주어야 한다. (team.getMembers().add(member))

- **연관관계 편의 메서드**

    - 연관관계 설정 시 한 쪽만 설정하는 실수를 할 수도 있으니, 다음과 같이 두 개의 연관관계 설정 코드를 한 코드에 묶은 것을 연관관계 편의 메서드라고 한다.

  ``` java
	 public void setTeam(Team team) {
        this.team = team;
	       team.getMembers().add(this);
	 }
  ```

#### - N + 1 문제

- 특정 객체를 대상으로 수행한 쿼리가 해당 객체가 가지고 있는 연관관계 또한 조회하게 되면서, **1**번의 쿼리로 **N**번의 추가적인 쿼리까지 발생하는 문제를 말한다.

- 예시 코드

  ``` java
  List<Member> members = memberRepository.findAll();
  for (Member member : members) {
      System.out.println(member.getOrders().size()); // 여기서 N + 1 문제 발생
  }
  ```

- 문제점

    - 1번의 쿼리로 여러 번의 요청이 나감 -> DB 부하, 비용 증가

    - 쿼리 수를 예측할 수 없다.

    - 응답 속도가 저하된다.

- 해결책

    - 연관관계의 fetch 전략을 지연로딩(fetchType.LAZY)으로 설정한다.

    - **fetch join** 방식으로 문제를 해결한다.

    - **@EntityGraph** 방식으로 문제를 해결한다.

    - **BatchSize**를 이용한다.

#### - JPA

- Java Persistence API

- 자바 객체를 데이터베이스에 저장(영속)하고, 관리하기 위한 표준 API

- JPA는 자바 객체를 알아서 테이블로 매핑해주는 표준 규약이다.

- JPA의 역할

    - 객체와 태이블 자동 매핑

    - CRUD SQL 자동 생성

    - 트랜잭션 관리

        - 영속성 컨텍스트로 일괄 관리

    - 캐시 관리

        - 1차 캐시를 사용해 중복 조회 최소화

    - 변경 감지(Dirty Checking)

        - 엔티티 값이 바뀌면 자동으로 update 쿼리 수행

- **영속성 컨텍스트**

    - 엔티티를 저장하고 관리하는 메모리 상의 1차 캐시 공간

    - 영속성 컨텍스트의 특징

        - 엔티티 저장

            - EntityManager를 통해 persist() 하면 일단 메모리에 저장한다.

        - 1차 캐시

            - 같은 엔티티를 다시 조회하면 DB에 안 가고 메모리에서 가져옴

        - 변경 감지(Dirty Checking)

            - 엔티티 값이 바뀌면 자동으로 update 쿼리 수행

        - 쓰기 지연

            - 트랜잭션 커밋 시점에 insert/update 쿼리를 한 번에 모아서 보낸다.

        - 엔티티 동일성 보장

    - **엔티티 상태**

        - 비영속(new)

            - 영속성 컨텍스트에 아직 등록되지 않은 상태

        - 영속(managed)

            - 영속성 컨텍스트에 의해 관리되는 상태

        - 준영속(detached)

            - 영속성 컨텍스트에서 분리된 상태

        - 삭제(removed)

            - 삭제 예약 상태(flush 시 delete 쿼리 발생)
  
  
  
  