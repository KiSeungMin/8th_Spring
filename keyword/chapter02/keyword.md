> #### Join

- Join 연산이란?

    - **두 개 이상의 테이블에서 공통된 컬럼을 기반으로 데이터를 합치는 연산**

- Join 연산의 종류

    - **Inner Join**

        - 양쪽 테이블 모두에 일치하는 데이터가 있을 때만 결과에 포함된다.

    - **Left Outer Join**

        - **왼쪽 테이블의 모든 행을 포함하고**, 오른쪽 테이블에 **일치하는 데이터가 있으면 같이, 없으면 NULL로 채운다.**

    - **Right Outer Join**

        - **Left Outer Join의 반대로**, 오른쪽 테이블 기준으로 전부 보여주고, 왼쪽 테이블은 있으면 보여주고 없으면 NULL로 채운다.

    - **Full Outer Join**

        - 양쪽 기준으로 전부 보여주며, 매칭 안 되는건 NULL로 채운다.

        - MySQL에서는 **UNION을 통해 구현할 수 있다.**

    - **카티션 곱**

        - 모든 행을 곱해서 조합한다.

        - A테이블에 5개, B 테이블에 3개가 있으면 결과는 3*5=15개이다.

- Join 연산 주의점

    - **ON절 또는 WHERE 절에 조인 조건이 빠지면 카티션 곱이 발생한다.**

    - **조인 대상 테이블이 1:N 관계일 때, 중복 행이 발생할 수 있다.**

        - 다음과 같이 학생이 같은 과목을 재수강 했다고 할 때,

      <img src = "https://velog.velcdn.com/images/sm011212/post/18803e1a-e695-4f6b-af61-5574c1d230c9/image.png" width = "200">

        - 중복 행이 발생하고, count(*) 했을 때도 별개의 데이터로 집계되어 카운트된다.

        - **DISTINCT**나 **GROUP BY + COUNT(*)을 써서 해결하자.**

      <img src = "https://velog.velcdn.com/images/sm011212/post/06a65e9f-9182-437e-9f78-6f320286207c/image.png" width = "200">

        - DISTINCT를 쓰면 위 처럼 중복 데이터는 제거된다.


- **모든 컬럼을 다 가져오면 불필요한 I/O와 메모리 사용이 발생하기 때문에, 필요한 컬럼만 명시해서 SELECT 하는게 좋다.**


- **조인 순서에 따라 성능이 달라진다.**

    - **EXPLAIN** : 쿼리가 실제로 어떻게 실행되는지 보여주는 명령어

        - 쿼리의 성능을 분석하고 최적화할 때 가장 중요한 도구 중 하나이다.

      <img src = "https://velog.velcdn.com/images/sm011212/post/902b9eb1-2e1f-40c4-895e-826dc093b231/image.png" width = "600">

        - explain 명령어를 사용하면 위와 같이 나오는데, type 컬럼의 값이 ref, eq_ref, const 일 때가 가장 이상적이다.

        - All이 나온다면 성능을 의심해봐야 한다.(풀 테이블 스캔 중)

        - Type에는 아래와 같은 값이 올 수 있으며, 위로 갈 수록 성능이 좋다.

      <img src = "https://velog.velcdn.com/images/sm011212/post/654ff3f5-1774-439b-8e72-730ac0b238e7/image.png" width="400">

<br>

> #### 페이징

- 페이징(Paging) 이란?

    - **많은 데이터 중 일부만 잘라서 가져오는 기법**

- 페이징이 필요한 이유

    - 데이터가 수천~수만 건이라면 한 번에 다 불러오는 건 비효율적이기 때문이다.

    - 서버 입장에서도 부하를 줄이고, 네트워크 비용을 절약할 수 있다.

- 페이징의 종류

    - OFFSET 페이징

    - 커서 기반 페이징

- 오프셋(OFFSET) 페이징

    - 오프셋 페이징 사용 예시

      ``` sql
	  SELECT * FROM 게시글
	  ORDER BY 작성일 DESC
	  LIMIT 10 OFFSET 10;
	  ```

    - 오프셋 페이징 계산 공식

      > **LIMIT = pageSize**

      > **OFFSET = (pageNumber - 1) * pageSize**

        - ex) pageNumber = 3, pageSize = 10일 때, 21~30번째 데이터가 조회된다.

    - 오프셋 페이징 사용의 장점

        - **특정 페이지로 이동이 가능하다.**

        - **구현이 쉽다.**

    - 오프셋 페이징 사용 주의점

        - **OFFSET이 클수록 느려진다. (커서 기반 페이징으로 해결 가능하다.)**

        - **실시간 데이터 변경에 취약하다.**

        - ORDER BY 없이 LIMIT만 쓸 경우, 결과 순서가 매번 달라질 수 있다.

- **커서 기반 페이징**

    - **마지막으로 본 데이터(커서)를 기준으로 다음 데이터를 가져오는 방식**

    - 쿼리 구조

      ``` sql
	  SELECT *
	  FROM 게시글
	  WHERE id < :lastSeenId
      ORDER BY id DESC
	  LIMIT 10;
	  ```

    - 커서 기반 페이징의 장점

        - **커서 기반 페이징은 페이지 번호가 커져도 항상 일정한 속도를 유지한다.**

    - 커서 기반 페이징 사용 주의점

        - **특정 페이지로 이동하기가 어렵다.**

        - **커서로 쓸 컬럼이 정렬 기준과 같아야 한다.**

        - **이전 페이지 구현이 까다롭다.*

- **각 페이징 방식은 어떨 때 적합할까?**

    - 오프셋 방식

        - 아무 페이지나 점프가 가능해야 할 때

        - 데이터 건수가 크지 않을 때

        - 전체 페이지 수를 정확히 보여줘야 할 때

    - 커서 기반 방식

        - 무한 스크롤 혹은 더보기 기능이 있을 때

        - 대량 데이터에서 성능이 중요할 때

        - 데이터가 자주 추가/삭제될 때

        - 정렬 기준이 명확할 때

 <br>

> #### SQL Injection

- SQL Injection 이란?

    - **SQL 쿼리에 악의적인 코드를 주입해서 DB를 조작하거나 해킹하는 공격 기법**

    - **사용자가 입력한 값이 SQL 문장 내부로 침투해서, 의도하지 않은 쿼리 실행을 유도한다.**

- 발생 예시

    - 만약 사용자가 **username: admin' -- **, **password: 빈칸**으로 입력한다면 다음과 같은 쿼리가 실행된다.

  ``` sql
	SELECT * FROM users WHERE username = 'admin' --' AND password = '';
  ```

  -> **뒤에 있는 조건이 무시되어 비밀번호 검증 없이 로그인이 성공한다.**

- SQL Injection 공격 예시

    - 인증 우회

        - 항상 참인 조건으로 로그인을 우회한다.

    - 데이터 유출

        - 다른 테이블을 조인해서 민감 정보를 노출한다.

    - 데이터 삭제

        - 사용자가 입력한 값이 끝나자마자, DROP TABLE을 실행해 데이터를 삭제한다.

- SQL Injection 방어 방법

    - JDBC :  **파라미터 바인딩 방식을 사용한다.**

      ``` java
      PreparedStatement ps = conn.prepareStatement("SELECT * FROM users WHERE id = ?");
      ps.setString(1, userInput);
      ```

      -> SQL과 사용자 입력을 완전히 분리해서 주입이 불가능하다.

    - ORM : **내부적으로 바인딩 처리를 자동으로 해준다.**

    - 입력 값 검증

        - 알파벳/숫자만 허용하거나, 특수문자를 제한한다.
  
  
  