## - 시니어 미션

#### - @DynamicInsert와 @DynamicUpdate가 어떻게 작동되는지 파악하기

- **기본적인 JPA의 동작 방식**

    - 엔티티의 모든 컬럼을 INSERT, UPDATE SQL에 포함시킨다.

    - 즉, 변경되지 않은 필드라도 모두 set 절에 포함시킨다.

- **@DynamicInsert의 동작 방식**

    - 엔티티 저장 시 null인 필드나 기본값이 지정된 필드를 SQL에서 제외한다.

- **@DynamicUpdate의 동작 방식**

    - 엔티티 수정 시 실제 변경된 필드만 UPDATE SQL에 포함한다.

#### - 기존 방식과 @DynamicInsert, @DynamicUpdate를 적용했을 때 장단점 파악하기

- **@DynamicInsert, @DynamicUpdate를 적용했을 때의 장점**

    - insert의 경우는 바인딩 파라미터 수가 감소하고, update의 경우는 변경 필드만 쿼리에 포함하기 때문에 SQL의 쿼리가 감소한다.

    - @DynamicInsert를 활용해 DB의 기본값을 활용할 수 있다.

    - Update 시 변경되지 않은 컬럼에 대한 불필요한 로깅, 트리거가 방지되어 락 충돌이 최소화된다.

- **@DynamicInsert, @DynamicUpdate를 적용했을 때의 단점**

    - 매번 다른 컬럼의 조합으로 이루어진 SQL이 생성되어 SQL 캐시 히트율이 저하된다.

    - Hibernate가 엔티티 상태를 dirty checking으로 비교해서 SQL을 생성하기 때문에 CPU 사용량이 증가한다.

    - 복잡한 매핑에서는 어떤 컬럼이 빠졌는지 파악이 어려워 디버깅이 번거로워질 수 있다.

#### - @DynamicInsert, @DynamicUpdate를 언제 적용하면 좋을지 파악하기

- **@DynamicInsert**

    - 에니티에 DB 기본값으로 정의된 컬럼이 많을 때

    - 일부 필드만 채우고 나머지는 DB가 자동으로 값을 넣도록 할 때

    - 생성 일시, UUID 자동 생성 등의 기본값 컬럼이 많을 때

- **@DynamicUpdate**

    - 엔티티의 필드가 많고, 일부 필드만 자주 수정될 때

    - 낙관적 락 버전 컬럼을 쓸 경우, 변경 없는 컬럼이 업데이트 되면서 충돌 위험이 높아질 때

- **적용하지 않는게 좋은 상황**

    - 컬럼이 많지 않은 엔티티

    - 수정 시 거의 모든 필드를 업데이트 하는 로직

    - PreparedStatement 캐시 히트율이 중요한 대량 처리

        - PreparedStatement 캐시란, Hibernate 등의 ORM이 이미 준비해 둔 SQL문을 다시 생성하지 않고 재사용하는 것을 말한다.

<br>

#### - Rest Docs가 무엇인지 알아보기

- 스프링 기반 애플리케이션의 REST API 문서를 테스트 코드에서 자동으로 추출해 주는 기능

- 테스트 실행 시 요청/응답 값, 헤더 필드 설명 등을 자동으로 캡쳐해 JSON, Curl 등의 파일을 생성한다.

#### - Swagger와 Rest Docs의 장단점 비교하기

- **Rest Docs의 장점**

    - 실제 테스트를 기반으로 문서를 생성한다.

    - API가 변경되면 테스트가 깨지기 때문에, 자동적으로 문서 갱신 요구가 생기고, 결국 코드와 문서의 일관성이 유지되는 효과가 생긴다.

    - 브라우저가 아닌 정적 호스팅이나 PDF 출력에도 용이하다.

    - 문서 스타일을 자유롭게 커스터마이징 할 수 있다.

- **Rest Docs의 단점**

    - 각 API 마다 테스트 코드를 추가해야 한다.

    - Swagger처럼 런타임의 UI를 지원하지 않는다.

    - 별도의 빌드 플로우를 통해 문서를 생성한다.

- **Swagger의 장점**

    - 실시간 UI를 제공해주어 브라우저에서 즉시 명세서를 확인할 수 있다.

    - 별도의 도구를 필요로 하지 않는다.

    - 인터페이스를 미리 정의하고 문서화하며 개발할 수 있다.

    - 어노테이션만 잘 설정하면 자동으로 동기화가 된다.

    - 다양한 도구와 통합이 쉽다.

- **Swagger의 단점**

    - 문서와 실제 구현이 일치하지 않을 수 있다는 단점이 있다.

    - 테스트 예시가 포함되지 않아 실제 샘플 데이터 예시를 보여주려면 별도의 작업이 필요하다.

    - 애플리케이션이 실행중일 때만 동작한다.

    - 커스터마이징이 복잡하다.

#### - Swagger와 Rest Docs를 각각 언제 적용하면 좋을지 파악하기

- **Rest Docs를 사용하면 좋을 때**

    - 테스트를 기반으로 문서의 일관성을 철저히 지키고 싶을 때

    - 문서의 신뢰도가 높아야 할 때

    - 정적 문서의 형태로 S3, Github Page 등에 호스팅하거나, 문서의 버전 관리가 필요할 때

    - 복잡한 템플릿 커스터마이징이 필요할 때

    - 테스트 데이터를 예시로 넣고 싶을 때

- **Swagger를 사용하면 좋을 때**

    - 클라이언트, 서버 간의 API를 미리 확정하고 개발을 병렬로 진행할 때

    - 별도 도구 없이도 즉시 공유할 수 있는 문서가 필요할 때

    - 애플리케이션 배포 시 UI가 자동으로 노출되어야 할 땐