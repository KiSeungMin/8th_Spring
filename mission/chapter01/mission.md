## - 미션1. 정규화에 따른 ERD 작성하기

### - 요구사항 제1 정규화 적용

#### - 제1 정규화란?

- **테이블의 컬럼이 원자값을 갖도록 테이블을 분해하는 것**

- **원자 값**

    - 한 필드에 저장되는 값이 더 이상 분해될 수 없는 최소 단위인 것

- ex) 한 컬럼에 여러 값이 들어있는 경우를 분리한다.

와이어 프레임을 분석해보면서, 제1 정규화를 다음과 같이 적용했다.
(저작권 이슈로 와이어 프레임 사진을 첨부하지 못했다.)

![](https://velog.velcdn.com/images/sm011212/post/66a08221-18e1-432c-b26a-584ea4f7f0b2/image.png)

- 생성 일시, 수정 일시, 삭제 일시(soft delete 대비)는 공통 필드이기에 따로 분리해 두었다.

- 각 도메인에 관한 정보들을 모두 한 번에 관리한다.


#### - 장점

- 테이블의 개수가 적다. -> **JOIN 연산의 횟수가 적어진다.**

#### - 단점

- **하나의 테이블 크기가 너무 커진다.**

    - 조회 시 성능에 영향을 끼친다.

- 선호 음식 종류, 이미지 등 **복수의 데이터가 저장 가능할 경우, 추가적인 행 삽입이 이루어지고, 중복 데이터 문제가 발생한다.**

    - 이미지를 추가로 저장할 때마다 행을 하나 추가해야 한다. -> 중복 데이터 + 성능 문제 + 조회 성능에 영향

- 가게 영업 일시의 경우도, 여러 개의 요일과 시간이 존재할 수 있다.

따라서 위 ERD에 대해 제2 정규화를 진행했다.

<br>

### - 제2 정규화 적용

#### - 제2 정규화란?

- 제1 정규화를 만족하며, **완전 함수 종속을 만족**하도록 테이블을 분해한 것

- **완전 함수 종속**

    - 한 속성이 후보 키 전체에 의존하는 것

    - ex) 두 개의 속성 A, B가 합쳐져 후보 키가 되었을 때, 다른 속성 C가 A와 B 둘 다에 의존하지만, A나 B 중 하나에만 의존하지 않는 것

    - 만약 C가 후보 키의 일부에만 의존한다면, 이는 제2 정규형 위반의 원인이 된다

위 ERD에 대해 제2 정규화를 적용해 다음과 같이 변경했다.

![](https://velog.velcdn.com/images/sm011212/post/6930ce79-378a-4e16-90d1-562be6490164/image.png)


#### - 변경사항

- **image url을 저장할 수 있도록 별도의 테이블로 분리했다.**

  -> 이미지를 여러 개 저장할 수 있다. 이미지에 대한 별도의 속성 값을 부여할 수 있다. (ex. 대표 이미지 설정 여부 등)

- **유저 선호 음식 필드를 별도의 테이블로 분리했다.**

  -> 유저 테이블의 별도의 행 추가 없이 여러 개의 유저 선호 음식을 관리할 수 있다.

- **가게 영업 일시를 별도의 테이블로 분리했다.**

  -> 각 요일별 영업 정보를 여러 개 추가해 관리할 수 있다. 별도의 속성 값을 부여할 수 있다. (ex. 격주로 영업 등)

#### - 장점

- 이미지, 유저 선호 음식, 가게 영업 일시 등 여러 개의 값이 가능한 필드를 중복 데이터 없이 저장할 수 있게 되었다.

- 각 필드에 대해 별도의 속성 값을 추가할 수 있다. (대표 이미지 설정 여부, 선호도 필드 등)

#### - 단점

- 여전히 각 테이블의 필드가 많이 존재한다.

  -> 조회 성능이 감소한다.

- 미션 테이블의 경우, 가게 정보 만으로도 미션과 보상을 알 수 있다.

  -> 중복 데이터가 발생한다.

<br>

### - 제3 정규화 적용 & 추가 수정

#### - 제3 정규화란?

- 제2 정규화를 진행한 테이블에 대해 **이행적 종속을 없애는 것**

- **이행적 종속**

    - A->B, B->C가 성립할 때, A->C가 성립되는 것

위 ERD에 대해 제3 정규화에 필요한 사항과, 추가적인 분리를 해주었다.

![](https://velog.velcdn.com/images/sm011212/post/01caba6f-4433-44ef-94f4-6c54512e9f22/image.png)

#### - 변경사항

- **미션 테이블을 유저 미션과, 미션 테이블로 분리했다.**

    - 특정 미션에 대해 조건과 달성, 가게 정보는 동일하고, 유저 정보와 미션의 성공 여부, 인증 번호가 달라지기 때문에, 해당 필드를 분리해주었다.

- **유저의 알림 설정 여부와 권한 설정 여부를 비식별 관계의 Embedded 타입으로 분리해주었다.**

    - 추후 알림, 권한 설정값이 추가될 때 관리가 용이해진다.

    - 유저 테이블에 과도하게 많은 정보가 들어가는 것을 방지해주었다.

#### - 장점

- 중복 데이터가 제거되었다.

- 각 테이블의 컬럼이 감소했다.

#### - 단점

- join 연산의 양이 더더욱 증가했다.

<br>

## - 미션2. 중복 요청 처리

### - 문제

한 사람이 “미션 도전!” 버튼을 빠르게 여러 번 눌렀을 때 여러 가지 이유(비동기 로직 등)로 요청이 지연되어 완전히 처리하기 전 두 번 요청이 들어갈 수 있다. 이를 해결할 수 있는 방법에는 무엇이 있을까?

### - 답변

위 문제는 프론트와 백엔드에서 각각 별도의 방지 로직을 처리할 수 있다.

#### - 프론트엔드 방지 로직

- 사용자가 “미션 도전!” 버튼을 클릭하면, 서버 응답이 올 때까지 **버튼을 일시적으로 비활성화(disable) 한다.**

- **디바운스(debounce)**, **스로틀(throttle)** 기법을 적용해 연속 클릭 시 일정 시간 동안 추가 클릭을 무시하도록 한다.

#### - 백엔드 방지 로직

- 요청에 대해 처리 여부 필드를 추가한다. (첫 요청 시 필드를 처리 중 or 처리 완료로 바꾼다.)

<br>

## - 회고

그동안 테이블 설계할 때 정규화를 잘 지켰는지에 관해 고민하지 않았던 것 같다. **정규화를 단계별로 적용해보면서 각 정규화의 의미를 다시 한 번 배울 수 있었고, 테이블을 보다 효율적으로 설계할 수 있었다.**

또, **테이블을 분리해서 데이터의 중복을 최소화하는 것이 결국 나중에 JOIN 연산의 추가로 이어지기 때문에, 정규화와 성능 사이에서 더 좋은 방안이 무엇인지 고민을 할 수 있었다.**

테이블을 설계하다보니 내가 DB 정규화, PK, FK 등의 개념과 MySQL에서 사용하는 자료형의 종류 등에 관해 명확하게 알고 있지 않다는 것을 깨달았다. 이번 기회에 DB에 대해 더 체계적으로 배워야겠다는 생각이 들었다.

